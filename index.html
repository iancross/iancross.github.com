<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <title>Dynamic Size Example</title>
   <script src="https://d3js.org/d3.v4.min.js"></script>
   <style>

  /* Make the chart container fill the page using CSS. */
  #chart {
      position: fixed;
      left: 0px;
      right: 0px;
      top: 0px;
      bottom: 0px;
   }  
   svg{
      background: black
   }
   </style>
</head>

<body>
  <div id="chart"></div>

  <script>

   var chartDiv = document.getElementById("chart");
   var svg = d3.select(chartDiv).append("svg");
   var diameter = 25;
   var width,height,circles_x,circles_y;
   var node_index_queue = []
   function redraw(){


         // Extract the width and height that was computed by CSS.
         width = chartDiv.clientWidth;
         height = chartDiv.clientHeight;
         circles_x = Math.floor(width/diameter) //get number of circles that can fit across
         circles_y = Math.floor(height/diameter) //and number of circles down

         // Use the extracted size to set the size of an SVG element.
         svg
         .attr("width", width)
         .attr("height", height);

         svg.selectAll("*").remove()

         svg.selectAll("circle")
            .data(d3.range(circles_x * circles_y))
            .enter()
            .append("circle")
            .attr("transform", function translate(d,i){
               return "translate(" + (diameter * (d % circles_x) + diameter) + "," + (Math.floor(d/circles_x) * diameter + diameter) + ")"
            })
            .attr("fill", "white")
            .attr("r", diameter/2)
            .attr("stroke", "black")
            .attr("stroke-width", 2)
            .style("pointer-events", "all")
            .on("click", function(d,i){
               circle_clicked(d, i, d3.select(this).attr("fill") );
            })    
      }   
      // Draw for the first time to initialize.
      redraw();
      // Redraw based on the new size whenever the browser window is resized.
      window.addEventListener("resize", redraw);
      
      function circle_clicked(d,index,old_color){        
         node_index_queue.push(index)
         var new_color = "rgb(" + Math.floor(Math.random() * 255) + "," +
            Math.floor(Math.random() * 255) + "," +
            Math.floor(Math.random() * 255) + ")"


         //.attr("fill",function(d,i){return color(i);});
         var delay_order = 0
         while (node_index_queue.length < d3.selectAll("circle").size()){ //begin our wave
            get_adjacent_nodes(node_index_queue[delay_order],old_color)
            //if (delay_order > 10) return;
            delay_order++

         }
         color_all_nodes(new_color)
      }
      //returns the indices above, right, below, and left (if available)
      //basically, all indices that need to be checked against
      function get_adjacent_nodes(index,old_color){
         //if not on the far left, get the left
         if (index % circles_x > 0) {
            maybe_push(index-1)
         }
         if (index % circles_x < circles_x - 1 ){
            maybe_push(index+1)
         } 

         //----------------------------------------------------------------

         if (Math.floor(index / circles_x) > 0) {
            maybe_push(index - circles_x);
         }
         if (Math.floor(index / circles_x) < circles_y - 1) {
            maybe_push(index + circles_x);
         }
      }
      function maybe_push(index){

         for(i = 0; i<node_index_queue.length; i++){
            if (node_index_queue[i] == index){
               return
            }
         }
         node_index_queue.push(index)

      }

      function color_all_nodes(new_color){
         circles = svg.selectAll("circle")
         for(i = 0; i<node_index_queue.length;i++){
            circles.each 
               (function (d,x) {
                  if (x == node_index_queue[i]){
                     d3.select(this)
                     .transition()
                     .delay(function() {
                        return Math.log(5 * i) * 500
                     })
                     .attr("fill", new_color)
                  }
               })

         }
      }
      /*function color_node_from_index(index,new_color,delay_order){
         svg.selectAll("circle")
            .each(function (d,i) { 
               if (i == index){
                  d3.select(this)
                  .transition()
                  .delay(function(d,i) {return (delay_order*100)})
                  .attr("fill", new_color)
               }
            })
      }*/


   </script>
   </body>
   </html>